<!-- ui styles -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Orbit Visualization with Textured Earth</title>
<style>
body { margin:0; overflow:hidden; background:black; color:white; font-family:sans-serif;}
canvas{display:block;}
#ui{
  position:absolute; top:10px; left:10px; z-index:10;
  background: rgba(0,0,0,0.5); padding:10px; border-radius:6px;
}

#timeSlider {
  position: absolute;
  top:10px;
  left:50%;
  transform: translateX(-50%);
  width:60%;
  z-index:11;
}
input, button{margin:2px 0; width:220px;}
</style>
</head>
<body>

<input type="range" id="timeSlider" min="0" max="1000" step="1">
<div id="ui">
  <input type="file" id="orbitFile" accept=".json"><br>
  <button id="pauseBtn">Resume</button><br>
  <label>Satellite Size</label>
  <input type="range" id="satSizeSlider" min="5" max="50" step="0.1" value="1"><br>
  Sim Time: <span id="simTime">--</span>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
let isPaused = true;
let orbitPoints = [];
let sunPoints = [];
let satMesh = null;
let orbitLine = null;
let frame = 0;
let startTime = null;
const scale = 0.01; // km to visualization units
const earthRadiusKm = 6371;
const slider = document.getElementById('timeSlider');
let deltaTime = 10; // default time step between data points in seconds
let earthAngle = 0; // initial Earth rotation angle
let angle = 0;

// -------------------- Scene --------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

// IMPORTANT: set far large enough for your scaled distances
const CAMERA_NEAR = 0.1;
const CAMERA_FAR = 1e7; // <- big enough for zooming out
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, CAMERA_NEAR, CAMERA_FAR);

// Position the camera a few Earth radii away (scaled)
camera.position.set(0, 0, 5 * scale * earthRadiusKm);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1); // crispness on hi-dpi
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

// set reasonable zoom limits (in the same scaled units)
controls.minDistance = 1.1 * scale * earthRadiusKm;          // can't zoom inside Earth
controls.maxDistance = 1e6 * scale * earthRadiusKm;         // large but finite

// -------------------- Earth --------------------
const earthGeometry = new THREE.SphereGeometry(1 * scale * earthRadiusKm, 64, 64);
const texLoader = new THREE.TextureLoader();
const earthMaterial = new THREE.MeshPhongMaterial({
  map: texLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'),
  bumpMap: texLoader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg'),
  bumpScale: 0.05,
  specularMap: texLoader.load('https://threejs.org/examples/textures/planets/earth_specular_2048.jpg'),
  specular: new THREE.Color('grey'),
  shininess: 5
});
const earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);

// Earth tilt (fixed)
const obliquity = THREE.MathUtils.degToRad(23.439281);
const qTilt = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), obliquity);
earthMesh.quaternion.copy(qTilt);

// Add axis helper (scaled)
const earthAxesHelper = new THREE.AxesHelper(2 * scale * earthRadiusKm);
earthMesh.add(earthAxesHelper);
scene.add(earthMesh);

// -------------------- Lights --------------------
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
sunLight.position.set(10, 0, 0);
scene.add(sunLight);

// Global axes
scene.add(new THREE.AxesHelper(2 * scale * earthRadiusKm));

// -------------------- UI Behavior --------------------
const pauseBtn = document.getElementById("pauseBtn");
pauseBtn.addEventListener("click", () => {
  isPaused = !isPaused;
  pauseBtn.textContent = isPaused ? "Resume" : "Pause";
});

document.getElementById('orbitFile').addEventListener('change', evt => {
  const file = evt.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    const data = JSON.parse(e.target.result);
    startTime = new Date(data.start_time);

    console.log("Loaded JSON keys:", Object.keys(data)); 

    // NOTE: your trajectory JSON is assumed already converted to Three.js order if you used the Python helpers
    orbitPoints = data.position_eci.map(p => new THREE.Vector3(p[0]*scale, p[1]*scale, p[2]*scale));
    sunPoints = data.sun_unit_vectors_eci.map(v => new THREE.Vector3(v[0], v[1], v[2]));
    deltaTime = data.t[1] - data.t[0]; // seconds between data points
    earthAngle = data.earth_rotation_angle; // initial Earth rotation angle

    if (orbitLine) scene.remove(orbitLine);
    const orbitGeo = new THREE.BufferGeometry().setFromPoints(orbitPoints);
    orbitLine = new THREE.Line(orbitGeo, new THREE.LineBasicMaterial({color:0xff0000}));
    scene.add(orbitLine);

    if (!satMesh) {
      const satGeom = new THREE.SphereGeometry(.1, 16, 16);
      const satMat = new THREE.MeshBasicMaterial({color:0xffff00});
      satMesh = new THREE.Mesh(satGeom, satMat);
      scene.add(satMesh);
    }
    satMesh.position.copy(orbitPoints[0]);

    frame = 0;
    slider.max = orbitPoints.length - 1;
    slider.value = 0;
  };
  reader.readAsText(file);
});

slider.addEventListener('input', e => {
  const idx = parseInt(e.target.value);
  if (orbitPoints.length && satMesh) {
    satMesh.position.copy(orbitPoints[idx]);
  }
  frame = idx;
});

const satSizeSlider = document.getElementById('satSizeSlider');
satSizeSlider.addEventListener('input', e => {
  if (satMesh) {
    const scaleFactor = parseFloat(e.target.value);
    satMesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
  }
});

// -------------------- Earth Rotation --------------------
const spinAxis = new THREE.Vector3(0, 1, 0).applyQuaternion(qTilt).normalize();
const SIDEREAL_DAY_S = 86164.0905;
const omegaSidereal = (2 * Math.PI) / SIDEREAL_DAY_S; // rad/s
let speedup = 5000;
let lastPerfTime = performance.now();
const OMEGA_EARTH = omegaSidereal;

function updateEarthRotation(frame) {
  const totalAngle = (earthAngle + OMEGA_EARTH * frame * deltaTime) % (2 * Math.PI);

  // Reset orientation to Earth's tilt
  earthMesh.quaternion.copy(qTilt);

  // Apply absolute rotation around spin axis
  const qRot = new THREE.Quaternion().setFromAxisAngle(spinAxis, totalAngle);
  earthMesh.quaternion.premultiply(qRot);
}

function animate() {
  requestAnimationFrame(animate);

  const now = performance.now();
  let dt = (now - lastPerfTime) / 1000.0;
  if (dt > 0.5) dt = 0.5;
  lastPerfTime = now;

  if (!isPaused && orbitPoints.length > 0) {
    frame = (frame + 1) % orbitPoints.length;
    satMesh.position.copy(orbitPoints[frame]);
    updateEarthRotation(frame);
    sunLight.position.copy(sunPoints[frame].clone().multiplyScalar(10));
    slider.value = frame;

    const dtSeconds = frame * deltaTime;
    const currentTime = new Date(startTime.getTime() + dtSeconds * 1000);
    document.getElementById('simTime').textContent = currentTime.toISOString();
  }

  controls.update();
  renderer.render(scene, camera);
}
animate();

// -------------------- Handle Resize --------------------
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>


