<!-- ui styles -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Orbit Visualization with Textured Earth</title>
<style>
body { margin:0; overflow:hidden; background:black; color:white; font-family:sans-serif;}
canvas{display:block;}
#ui{
  position:absolute; top:10px; left:10px; z-index:10;
  background: rgba(0,0,0,0.5); padding:10px; border-radius:6px;
}

#timeSlider {
  position: absolute;
  top:10px;
  left:50%;
  transform: translateX(-50%);
  width:60%;
  z-index:11;
}
input, button{margin:2px 0; width:220px;}
</style>
</head>
<body>

<input type="range" id="timeSlider" min="0" max="1000" step="1">
<div id="ui">
  <input type="file" id="orbitFile" accept=".json"><br><br>
  <button id="pauseBtn">Resume</button><br>
  Sim Time: <span id="simTime">--</span><br>
  Time Step and Visualization Rate: <span id="timeStepDisplay">--</span> seconds<br>
  Visualization Rate: <span id="visRateDisplay">--</span> s/frame<br>
  Simulation Speed: <span id="simSpeedDisplay">--</span>× real-time<br>
  FPS: <span id="fpsDisplay">--</span><br><br>
  <label for="simulationSpeedSlider">Simulation Speed</label>
  <input type="range" id="simulationSpeedSlider" min="0.01" max="20" step="0.01" value="1"><br><br>
  <label>Satellite Size</label>
  <input type="range" id="satSizeSlider" min="5" max="50" step="0.1" value="5"><br><br>
  <label for="cameraTargetSelect">Camera Target:</label>
  <select id="cameraTargetSelect">
    <option value="earth" selected>Earth</option>
    <option value="moon">Moon</option>
    <option value="satellite">Satellite</option>
  </select>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
let isPaused = true;
let orbitPoints = [];
let sunPoints = [];
let moonPositions = [];
let satMesh = null;
let orbitLine = null;
let frame = 0;
let startTime = null;
const scale = 0.01; // km to visualization units
const earthRadiusKm = 6371;
const slider = document.getElementById('timeSlider');
let deltaTime = 10; // default time step between data points in seconds
let earthAngle = 0; // initial Earth rotation angle
let angle = 0;
let cameraTargetMode = "earth"; // default
let smoothedFps = 60; // start with a reasonable guess
const FPS_SMOOTH = 0.9; // smoothing factor for stability

// -------------------- Scene --------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

// IMPORTANT: set far large enough for your scaled distances
const CAMERA_NEAR = 0.1;
const CAMERA_FAR = 1e7; // <- big enough for zooming out
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, CAMERA_NEAR, CAMERA_FAR);

// Position the camera a few Earth radii away (scaled)
camera.position.set(0, 0, 5 * scale * earthRadiusKm);
camera.lookAt(0,0,0);

const defaultCameraPos = new THREE.Vector3(0, 0, 5 * scale * earthRadiusKm);
const defaultCameraTarget = new THREE.Vector3(0, 0, 0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1); // crispness on hi-dpi
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

// set reasonable zoom limits (in the same scaled units)
controls.minDistance = 1.1 * scale * earthRadiusKm;          // can't zoom inside Earth
controls.maxDistance = 1e6 * scale * earthRadiusKm;         // large but finite

// -------------------- Moon --------------------
const moonGeometry = new THREE.SphereGeometry(0.27 * scale * earthRadiusKm, 32, 32);
const moonMaterial = new THREE.MeshPhongMaterial({
  map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/moon_1024.jpg')
});
const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
moonMesh.position.set(5 * scale * earthRadiusKm, 0, 0);
scene.add(moonMesh);

// -------------------- Earth --------------------
const earthGeometry = new THREE.SphereGeometry(1 * scale * earthRadiusKm, 64, 64);
const texLoader = new THREE.TextureLoader();
const earthMaterial = new THREE.MeshPhongMaterial({
  map: texLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'),
  bumpMap: texLoader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg'),
  bumpScale: 0.05,
  specularMap: texLoader.load('https://threejs.org/examples/textures/planets/earth_specular_2048.jpg'),
  specular: new THREE.Color('grey'),
  shininess: 5
});
const earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);

earthMesh.rotation.set(0, 0, 0);

// Add axis helper (scaled)
const earthAxesHelper = new THREE.AxesHelper(2 * scale * earthRadiusKm);
earthMesh.add(earthAxesHelper);
scene.add(earthMesh);

// -------------------- Earth Atmosphere (Ozone Glow) --------------------
const atmosphereGeometry = new THREE.SphereGeometry(1.02 * scale * earthRadiusKm, 64, 64);
const atmosphereMaterial = new THREE.ShaderMaterial({
  uniforms: {
    "c": { type: "f", value: 0.3 },
    "p": { type: "f", value: .5 },
    glowColor: { type: "c", value: new THREE.Color(0x00b3ff) },
    viewVector: { type: "v3", value: camera.position }
  },
  vertexShader: `
    uniform vec3 viewVector;
    uniform float c;
    uniform float p;
    varying float intensity;
    void main() {
      vec3 vNormal = normalize(normalMatrix * normal);
      vec3 vNormel = normalize(normalMatrix * viewVector - (modelViewMatrix * vec4(position, 1.0)).xyz);
      intensity = pow(c - dot(vNormal, vNormel), p);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 glowColor;
    varying float intensity;
    void main() {
      vec3 glow = glowColor * intensity;
      gl_FragColor = vec4(glow, 1.0);
    }
  `,
  side: THREE.BackSide,
  blending: THREE.AdditiveBlending,
  transparent: true
});

const atmosphereMesh = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
earthMesh.add(atmosphereMesh);


// -------------------- Lights --------------------
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const sunLight = new THREE.DirectionalLight(0xffffff, 2);
sunLight.position.set(500, 0, 0);
scene.add(sunLight);

// Global axes
scene.add(new THREE.AxesHelper(100 * scale * earthRadiusKm));

// -------------------- Grid (scaled to Earth radius) --------------------
// Create a grid with 20x20 cells, each cell = 1 Earth radius
const gridSize = 500 * scale * earthRadiusKm;  // total grid size
const gridDivisions = 500;                       // number of cells
// Equatorial grid (XZ plane) — default GridHelper lies in XZ, so this is the equator.
const equatorGrid = new THREE.GridHelper(gridSize, gridDivisions, 0x444444, 0x222222);
equatorGrid.position.set(0, 0, 0);
scene.add(equatorGrid);

// Meridian grid (YZ plane) — rotate XZ -> YZ by rotating about Z by +90°
const meridianGrid = new THREE.GridHelper(gridSize, gridDivisions, 0x336699, 0x223344);
meridianGrid.rotation.z = Math.PI / 2;
meridianGrid.position.set(0, 0, 0);
scene.add(meridianGrid);

// Polar/axial grid (XY plane) — rotate XZ -> XY by rotating about X by +90°
const axialGrid = new THREE.GridHelper(gridSize, gridDivisions, 0x663366, 0x332233);
axialGrid.rotation.x = Math.PI / 2;
axialGrid.position.set(0, 0, 0);
scene.add(axialGrid);

// -------------------- Sun and Moon Direction Arrows --------------------
// Arrow pointing to the Sun (yellow)
const sunArrowOrigin = new THREE.Vector3(0, 0, 0);
const sunArrowDir = new THREE.Vector3(1, 0, 0);
const sunArrowLength = 3 * scale * earthRadiusKm;
const sunArrow = new THREE.ArrowHelper(sunArrowDir, sunArrowOrigin, sunArrowLength, 0xffff00);
scene.add(sunArrow);

// Arrow pointing to the Moon (white)
const moonArrowOrigin = new THREE.Vector3(0, 0, 0);
const moonArrowDir = new THREE.Vector3(1, 0, 0);
const moonArrowLength = 3 * scale * earthRadiusKm;
const moonArrow = new THREE.ArrowHelper(moonArrowDir, moonArrowOrigin, moonArrowLength, 0xffffff);
scene.add(moonArrow);

// -------------------- UI Behavior --------------------
const pauseBtn = document.getElementById("pauseBtn");
pauseBtn.addEventListener("click", () => {
  isPaused = !isPaused;
  pauseBtn.textContent = isPaused ? "Resume" : "Pause";
});

document.getElementById('orbitFile').addEventListener('change', evt => {
  const file = evt.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    const data = JSON.parse(e.target.result);
    startTime = new Date(data.start_time);

    console.log("Loaded JSON keys:", Object.keys(data)); 

    // NOTE: your trajectory JSON is assumed already converted to Three.js order if you used the Python helpers
    orbitPoints = data.position_eci.map(p => new THREE.Vector3(p[0]*scale, p[1]*scale, p[2]*scale));
    sunPoints = data.sun_unit_vectors_eci.map(v => new THREE.Vector3(v[0], v[1], v[2]));
    deltaTime = data.t[1] - data.t[0]; // seconds between data points
    earthAngle = data.earth_rotation_angle; // initial Earth rotation angle
    moonPositions = data.moon_positions_eci.map(p => new THREE.Vector3(p[0]*scale, p[1]*scale, p[2]*scale));

    if (orbitLine) scene.remove(orbitLine);
    const orbitGeo = new THREE.BufferGeometry().setFromPoints(orbitPoints);
    orbitLine = new THREE.Line(orbitGeo, new THREE.LineBasicMaterial({color:0xff0000}));
    scene.add(orbitLine);

    if (!satMesh) {
      const satGeom = new THREE.SphereGeometry(.1, 16, 16);
      const satMat = new THREE.MeshBasicMaterial({color:0xffff00});
      satMesh = new THREE.Mesh(satGeom, satMat);
      scene.add(satMesh);
    }
    satMesh.position.copy(orbitPoints[0]);

    frame = 0;
    slider.max = orbitPoints.length - 1;
    slider.value = 0;
  };
  reader.readAsText(file);
});

slider.addEventListener('input', e => {
  const idx = parseInt(e.target.value);
  if (orbitPoints.length && satMesh) {
    satMesh.position.copy(orbitPoints[idx]);
    updateEarthRotation(idx);
    sunLight.position.copy(sunPoints[idx].clone().multiplyScalar(10));
    moonMesh.position.copy(moonPositions[idx]);
    
    // Update arrow directions when scrubbing
    const sunDir = sunPoints[idx].clone().normalize();
    sunArrow.setDirection(sunDir);
    
    const moonDir = moonPositions[idx].clone().normalize();
    moonArrow.setDirection(moonDir);
  }
  frame = idx;
  if (startTime && deltaTime) {
    const dtSeconds = frame * deltaTime;
    const currentTime = new Date(startTime.getTime() + dtSeconds * 1000);
    document.getElementById('simTime').textContent = currentTime.toISOString();
    document.getElementById('timeStepDisplay').textContent = deltaTime.toFixed(2);
    document.getElementById('visRateDisplay').textContent = (deltaTime * speedup).toFixed(2);
    document.getElementById('simSpeedDisplay').textContent = simRate.toFixed(0);
    document.getElementById('fpsDisplay').textContent = smoothedFps.toFixed(1);
  }
});

const satSizeSlider = document.getElementById('satSizeSlider');
satSizeSlider.addEventListener('input', e => {
  if (satMesh) {
    const scaleFactor = parseFloat(e.target.value);
    satMesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
  }
});

document.getElementById('cameraTargetSelect').addEventListener('change', e => {
  cameraTargetMode = e.target.value;
});

document.getElementById('simulationSpeedSlider').addEventListener('input', e => {
  speedup = parseFloat(e.target.value);
});



// -------------------- Earth Rotation --------------------
const spinAxis = new THREE.Vector3(0, 1, 0)
const SIDEREAL_DAY_S = 86164.0905;
const omegaSidereal = (2 * Math.PI) / SIDEREAL_DAY_S; // rad/s
let speedup = 1;
let lastPerfTime = performance.now();
const OMEGA_EARTH = omegaSidereal;

function updateEarthRotation(frame) {
  const totalAngle = (earthAngle + OMEGA_EARTH * frame * deltaTime) % (2 * Math.PI);

  // base tilt quaternion
  const baseQuat = new THREE.Quaternion();

  // rotation about spin axis
  const rotQuat = new THREE.Quaternion().setFromAxisAngle(spinAxis, totalAngle);

  // final orientation = spin * tilt
  earthMesh.quaternion.copy(rotQuat).multiply(baseQuat);
}

let fractionalFrame = 0;

function animate() {
  requestAnimationFrame(animate);

  const now = performance.now();
  let dt = (now - lastPerfTime) / 1000.0;
  if (dt > 0.5) dt = 0.5;
  lastPerfTime = now;

  if (dt > 0 && dt < 1) {
    smoothedFps = FPS_SMOOTH * smoothedFps + (1 - FPS_SMOOTH) * (1 / dt);
  }

  if (!isPaused && orbitPoints.length > 0) {
    fractionalFrame += speedup;
    frame = Math.floor(fractionalFrame) % orbitPoints.length;
    // frame = (frame + speedup) % orbitPoints.length;
    satMesh.position.copy(orbitPoints[frame]);
    updateEarthRotation(frame);
    sunLight.position.copy(sunPoints[frame].clone().multiplyScalar(10));
    moonMesh.position.copy(moonPositions[frame]);
    
    // Update arrow directions to point to Sun and Moon
    const sunDir = sunPoints[frame].clone().normalize();
    sunArrow.setDirection(sunDir);
    
    const moonDir = moonPositions[frame].clone().normalize();
    moonArrow.setDirection(moonDir);
    
    slider.value = frame;

    const dtSeconds = frame * deltaTime;
    const currentTime = new Date(startTime.getTime() + dtSeconds * 1000);
    document.getElementById('simTime').textContent = currentTime.toISOString();
    document.getElementById('timeStepDisplay').textContent = deltaTime.toFixed(2);
    document.getElementById('visRateDisplay').textContent = (deltaTime * speedup).toFixed(2);
    document.getElementById('fpsDisplay').textContent = smoothedFps.toFixed(1);
  }

    // Update camera target position based on selected mode
  const simRate = deltaTime * speedup * smoothedFps; 
  document.getElementById('simSpeedDisplay').textContent = simRate.toFixed(0);
  let targetPosition = new THREE.Vector3();

  if (cameraTargetMode === "earth") {
    earthMesh.getWorldPosition(targetPosition);
  } else if (cameraTargetMode === "moon") {
    moonMesh.getWorldPosition(targetPosition);
  } else if (cameraTargetMode === "satellite" && satMesh) {
    satMesh.getWorldPosition(targetPosition);
  }

  // Option 1: camera orbits freely but focuses on the target
  controls.target.lerp(targetPosition, 0.1); // smooth follow

  controls.update();
  renderer.render(scene, camera);
}
animate();

// -------------------- Handle Resize --------------------
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>


